Token: SEPARATOR, Lexeme: $$
Token: KEYWORD, Lexeme: function
Token: IDENTIFIER, Lexeme: convertx
Token: SEPARATOR, Lexeme: (
Token: IDENTIFIER, Lexeme: fahr
	Production: <IDs> -> <Identifier> | <Identifier>, <IDs>
Token: KEYWORD, Lexeme: integer
	Production: <Qualifier> -> integer | boolean | real
	Production: <Parameter> -> <IDs> <Qualifier>
	Production: <Parameter List> -> <Parameter> | <Parameter> , <Parameter List>
	Production: <Opt Parameter List> -> <Parameter List> | <Empty>
Token: SEPARATOR, Lexeme: )
	Production: <Opt Declaration List> -> <Declaration List> | <Empty>
Token: SEPARATOR, Lexeme: {
Token: KEYWORD, Lexeme: return
Token: INTEGER, Lexeme: 5
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
Token: OPERATOR, Lexeme: *
Token: SEPARATOR, Lexeme: (
Token: IDENTIFIER, Lexeme: fahr
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
Token: OPERATOR, Lexeme: -
Token: INTEGER, Lexeme: 32
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
	Production: <Expression> -> + <Term> <Expression> | - <Term> <Expression> | <Empty>
	Production: <Expression> -> + <Term> <Expression> | - <Term> <Expression> | <Empty>
Token: SEPARATOR, Lexeme: )
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
Token: OPERATOR, Lexeme: /
Token: INTEGER, Lexeme: 9
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
	Production: <Expression> -> + <Term> <Expression> | - <Term> <Expression> | <Empty>
Token: SEPARATOR, Lexeme: ;
	Production: <Return> -> return ; | return <Expression>
	Production: <Statement> -> <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
	Production: <Statement List> -> <Statement> <Statement List>
Token: SEPARATOR, Lexeme: }
	Production: <Body> -> { <Statement List> }
	Production: <Function> -> function <Identifier> ( <Opt Parameter List> ) <Opt Declaration List> <Body>
	Production: <Function Definitions> -> <Function> | <Function> <Function Definitions>
	Production: <Opt Function Definitions> -> <Function Definitions> | <Empty>
Token: SEPARATOR, Lexeme: $$
Token: KEYWORD, Lexeme: integer
	Production: <Qualifier> -> integer | boolean | real
Token: IDENTIFIER, Lexeme: low
Token: SEPARATOR, Lexeme: ,
Token: IDENTIFIER, Lexeme: high
Token: SEPARATOR, Lexeme: ,
Token: IDENTIFIER, Lexeme: step
	Production: <IDs> -> <Identifier> | <Identifier>, <IDs>
	Production: <IDs> -> <Identifier> | <Identifier>, <IDs>
	Production: <IDs> -> <Identifier> | <Identifier>, <IDs>
Token: SEPARATOR, Lexeme: ;
	Production: <Declaration> -> <Qualifier> <IDs>
	Production: <Declaration List> -> <Declaration> | <Declaration> <Declaration List>
	Production: <Opt Declaration List> -> <Declaration List> | <Empty>
Token: SEPARATOR, Lexeme: $$
Token: KEYWORD, Lexeme: scan
Token: SEPARATOR, Lexeme: (
Token: IDENTIFIER, Lexeme: low
Token: SEPARATOR, Lexeme: ,
Token: IDENTIFIER, Lexeme: high
Token: SEPARATOR, Lexeme: ,
Token: IDENTIFIER, Lexeme: step
	Production: <IDs> -> <Identifier> | <Identifier>, <IDs>
	Production: <IDs> -> <Identifier> | <Identifier>, <IDs>
	Production: <IDs> -> <Identifier> | <Identifier>, <IDs>
Token: SEPARATOR, Lexeme: )
Token: SEPARATOR, Lexeme: ;
	Production: <Scan Statement> -> scan ( <IDs> )
	Production: <Statement> -> <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
Token: KEYWORD, Lexeme: while
Token: SEPARATOR, Lexeme: (
Token: IDENTIFIER, Lexeme: low
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
	Production: <Expression> -> + <Term> <Expression> | - <Term> <Expression> | <Empty>
Token: OPERATOR, Lexeme: <=
	Production: <Relop> -> == | != | > | < | <= | >=
Token: IDENTIFIER, Lexeme: high
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
	Production: <Expression> -> + <Term> <Expression> | - <Term> <Expression> | <Empty>
	Production: <Condition> -> <Expression> <Relop> <Expression>
Token: SEPARATOR, Lexeme: )
Token: SEPARATOR, Lexeme: {
Token: KEYWORD, Lexeme: print
Token: SEPARATOR, Lexeme: (
Token: IDENTIFIER, Lexeme: low
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
	Production: <Expression> -> + <Term> <Expression> | - <Term> <Expression> | <Empty>
Token: SEPARATOR, Lexeme: )
Token: SEPARATOR, Lexeme: ;
	Production:  <Print> -> print ( <Expression>)
	Production: <Statement> -> <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
Token: KEYWORD, Lexeme: print
Token: SEPARATOR, Lexeme: (
Token: IDENTIFIER, Lexeme: convertx
Token: SEPARATOR, Lexeme: (
Token: IDENTIFIER, Lexeme: low
	Production: <IDs> -> <Identifier> | <Identifier>, <IDs>
Token: SEPARATOR, Lexeme: )
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
	Production: <Expression> -> + <Term> <Expression> | - <Term> <Expression> | <Empty>
Token: SEPARATOR, Lexeme: )
Token: SEPARATOR, Lexeme: ;
	Production:  <Print> -> print ( <Expression>)
	Production: <Statement> -> <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
Token: IDENTIFIER, Lexeme: low
Token: OPERATOR, Lexeme: =
Token: IDENTIFIER, Lexeme: low
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
Token: OPERATOR, Lexeme: +
Token: IDENTIFIER, Lexeme: step
	Production: <Primary> -> <Identifier> | <Integer> | <Identifier> ( <IDs>) | ( <Expression> ) | <Real> | true | false
	Production: <Factor> -> <Primary> | <Primary>
	Production: <Term> -> <Factor> | <Factor> <Mulop> <Term>
	Production: <Expression> -> + <Term> <Expression> | - <Term> <Expression> | <Empty>
	Production: <Expression> -> + <Term> <Expression> | - <Term> <Expression> | <Empty>
Token: SEPARATOR, Lexeme: ;
	Production:  <Assign> -> <Identifier> = <Expression>
	Production: <Statement> -> <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
	Production: <Statement List> -> <Statement> <Statement List>
	Production: <Statement List> -> <Statement> <Statement List>
	Production: <Statement List> -> <Statement> <Statement List>
Token: SEPARATOR, Lexeme: }
	Production: <Compound> -> { <Statement List> }
	Production: <Statement> -> <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
Token: KEYWORD, Lexeme: endwhile
	Production: <While Statement> -> while ( <Expression> ) <Statement>
	Production: <Statement> -> <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
	Production: <Statement List> -> <Statement> <Statement List>
	Production: <Statement List> -> <Statement> <Statement List>
Token: SEPARATOR, Lexeme: $$
	Production: <Rat25S> -> $$ <Opt Function Definitions> $$ <Opt Declaration List> $$ <Statement List> $$
Parsing completed successfully!
